jmp far 指令实现代码跨段，本质上就是改变 cs 和 eip。但是无论如何，jmp far 也无法更改 CPL。本文讲述如何实现跨段跳转并提权。

CPU只允许CPL为0、1、2的程序访问高2G内存。无论如何，在3环下你也读不了这个地址的内存。唯一的方法就是，让你的特权级变成0、1、2。

调用门，是CPU提供给我们的一个功能，它允许 3 环程序（CPL=3）通过这扇“门”达到修改 cs 段寄存器的目的，同时达到提权的目的。

"门"，是一种系统段描述符（段描述符的 S=0），这个描述符的结构和数据段描述符和代码段描述符有很大区别，这种描述符中嵌入了选择子。如果你在"门"嵌入DPL=0的代码段选择子，那么你在 3 环，就可以通过这扇门，到达0环领空，这时候你的CPL=3就变成CPL=0。调用门就具备了这种功能。你可以在调用门中嵌入选择子 0x0008，这个选择子指向的是 DPL = 0的代码段。然后使用 call far + 调用门描述符的段选择子，跨段到 0x0008 指向的代码段。

call far 指令对堆栈的影响
跨段提权，该指令首先会切换堆栈。在新栈中压入3环的ss，esp，cs，eip
跨段不提权，该指令不需要切换栈，也不需要保存3环栈段寄存器 ss 和 esp了，只需要压入3环的cs，eip

指令：CALL  CS:EIP(EIP是废弃的)
所有信息都根据CS获取，这个CS是段选择子，指向GDT表中的一个特殊的“段”，这个特殊的“段”叫调用门。在提权长调用中，0环堆栈除了返回地址，调用者CS以外，还压入了调用者的SS和ESP，这部分数据是从TSS段中获取的。

调用门描述符结构
|   7    |     6  |     5     |    4    |   3    |   2    |   1    |   0    |  字节
|76543210|76543210|7 65 4 3210|765 43210|76543210|76543210|76543210|76543210|  比特
|-----------------|1|--|0|1100|000|-----|--------|--------|--------|--------|  占位
|offset in segment|P|D |S|TYPE|   |param|segment selector |offset in segment|  含义
|     31-16         |P |          |nums |                 |       15-0      |
                    |L |
这个很像段描述符（不像就出问题了，哈哈哈）
P位，DPL位，S位，TYPE位意义都不变（与段描述符相同），要求：P=1，DPL=当前CPL(一般为3，否则没有敲门权利)，TYPE=1100
offset in segment：新的EIP入口地址值（调用门主要改这个值）
segment selector：段选择子（往哪个段跳，就写对应的段选择子，这个段选择子可以是0环的）
通过上面offset in segment和segment selector两个部分：CALL FAR CS:EIP指令里面的CS和EIP就都有了，大功告成。

实验步骤
1.根据CS值查GDT表，找到对应的段描述符，这个描述符是一个调用门
2.在调用门描述符中segment selector写入另一个代码段的段选择子（可以是0环，也可以是3环，如果是3环就不提权，如果是0环就提权，但是堆栈变化我们在代码层是感受不到的，因为我们只使用CALL FAR和RETF，堆栈切换不切换都是指令自己决定和完成的）
3.选择子指向的段BASE+偏移地址，写入调用门描述符的offset in segment，就是真正的要执行的地址

具体操作
1.查看当前段，没有调用门描述符，需要自己构造一个
查看代码，函数入口点地址：0040B7B0
0040ec00`0008b7b0
kd> dq 8003f000 
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008954`b1000068 80008954`b1680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff
kd> eq 8003f048 0040ec00`0008b7b0
kd> dq 8003f000
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 0040ec00`0008b7b0
8003f050  80008954`b1000068 80008954`b1680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

2.代码
#include "stdafx.h"
#include <windows.h>
#include <stdio.h>

WORD g_cs0, g_ss0, g_ds0, g_es0, g_fs0, g_gs0;
DWORD r0_data_lowdword, r0_data_hidword;

__declspec(naked) void getData() { //反汇编后函数地址：0040B7B0
	__asm {
		pushfd
		pushad
		mov g_cs0, cs
		mov g_ss0, ss
		mov g_ds0, ds
		mov g_es0, es
		mov g_fs0, fs
		mov g_gs0, gs
		mov eax, 0x8003f048 //访问高2G内存
		mov eax, [eax]
		mov r0_data_lowdword, eax
		mov eax, 0x8003f04c //访问高2G内存
		mov eax, [eax]
		mov r0_data_hidword, eax
		popad
		popfd
		retf
	}
}

void printData() {
	printf("g_cs0=%02x\ng_ss0=%02x\ng_ds0=%02x\ng_es0=%02x\ng_fs0=%02x\ng_gs0=%02x\nr0_data(0x8003f048)=%08x %08x\n", 
		g_cs0, g_ss0, g_ds0, g_es0, g_fs0, g_gs0, r0_data_hidword, r0_data_lowdword);//观察寄存器变化
}

int main(int argc, char* argv[]) {
	char cs_eip[6] = {0, 0, 0, 0, 0x48, 0}; //这里的eip被废弃
	__asm {
		call fword ptr [cs_eip] //相当于CALL FAR 0x48:0x00000000 ,VC6.0 中不支持这种写法，这行代码进入调用门，在调用门里面获得了新的CS和EIP，冒号后面地址随便填，因为是废弃的
	}
	printData();
	getchar();
	return 0;
}

提权后通用寄存器有没有发生变化？通过实验得知，没有变化，0环和3环的寄存器数据是一样的。

总结
1.跨段调用时，一旦有权限切换，就会切换堆栈.
2.CS的权限一旦改变，SS的权限也要随着改变，CS与SS的等级必须一样.
3.JMP FAR 只能跳转到同级非一致代码段，但CALL FAR可以通过调用门提权，提升CPL的权限.
4.调用门虽然是 CPU 提供给使用者提权的一种手段，但是 Windows 中却并未使用。在 Windows 中，大量使用了中断门来进行提权，包括后面的系统调用，都是采用中断的方式实现。
5.所谓的后门，其实有很多，比如中断门，陷阱门，任务门。它们都可以实现提权。

