IDT表里面就三种内容：任务门描述符、中断门描述符、陷阱门描述符。

陷阱门描述符
|   7    |     6  |     5     |   4    |   3    |   2    |   1    |   0    |  字节
|76543210|76543210|7 65 4 3210|76543210|76543210|76543210|76543210|76543210|  比特
|-----------------|1|--|0|1111|--------|--------|--------|--------|--------|  占位
|offset in segment|P|D |S|TYPE|        |segment selector |offset in segment|  含义
|     31-16         |P |               |                 |       15-0      |
                    |L |
是不是还是和段描述符很像（哈哈哈）
P=1有效，S=0系统段描述符，TYPE位是关键，0xf表示陷阱门。陷阱门不可以传参数。
int x 指令，x是索引，x*8 + IDT的基地址，就是具体的中断门描述符
int x指令进入中断后，如果没有权限切换（不切换堆栈）会push三个寄存器值（eflags cs eip），如果有提权，会想堆栈push5个寄存器值（ss esp eflags cs eip），所以不能用retf返回，而是使用iret或者iretd返回
offset in segment：新的EIP入口地址值（陷阱门主要改这个值）
segment selector：段选择子（往哪个段跳，就写对应的段选择子，这个段选择子可以是0环的）
通过上面offset in segment和segment selector两个部分：INT x指令进入中断门，里面的CS和EIP就都有了，大功告成。

中断门和陷阱门区别：就是对eflags寄存器的影响。中断门CPU会把EFLAGS中的IF位置0，而进入陷阱门，CPU并不修改 IF 位。（IF置0表示不响应可屏蔽中断，IF置1表示响应可屏蔽中断。IF对不可屏蔽中断无影响。键盘输入就是可屏蔽中断，按电源键就是不可屏蔽中断。）

实验步骤：与中断门完全相同，仅仅是陷阱门描述符为：0040ee00`00081020（函数的偏移地址00401020）
可以在裸函数内执行int 3，查看EFLAGS寄存器

windows不使用陷阱门(idt表中没有陷阱门描述符）。
