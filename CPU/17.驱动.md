先了解一下3环断链：
TEB：线程环境快，FS:[0],存储的就是TEB的地址，每个线程都有这样一个结构体，结构体信息如下：
kd> dt _TEB
ntdll!_TEB
   +0x000 NtTib            : _NT_TIB
   +0x01c EnvironmentPointer : Ptr32 Void
   +0x020 ClientId         : _CLIENT_ID
   +0x028 ActiveRpcHandle  : Ptr32 Void
   +0x02c ThreadLocalStoragePointer : Ptr32 Void
   +0x030 ProcessEnvironmentBlock : Ptr32 _PEB
   +0x034 LastErrorValue   : Uint4B
   +0x038 CountOfOwnedCriticalSections : Uint4B
   +0x03c CsrClientThread  : Ptr32 Void
   +0x040 Win32ThreadInfo  : Ptr32 Void
   +0x044 User32Reserved   : [26] Uint4B
   +0x0ac UserReserved     : [5] Uint4B
   +0x0c0 WOW32Reserved    : Ptr32 Void
   +0x0c4 CurrentLocale    : Uint4B
   +0x0c8 FpSoftwareStatusRegister : Uint4B
   +0x0cc SystemReserved1  : [54] Ptr32 Void
   +0x1a4 ExceptionCode    : Int4B
   +0x1a8 ActivationContextStack : _ACTIVATION_CONTEXT_STACK
   +0x1bc SpareBytes1      : [24] UChar
   +0x1d4 GdiTebBatch      : _GDI_TEB_BATCH
   +0x6b4 RealClientId     : _CLIENT_ID
   +0x6bc GdiCachedProcessHandle : Ptr32 Void
   +0x6c0 GdiClientPID     : Uint4B
   +0x6c4 GdiClientTID     : Uint4B
   +0x6c8 GdiThreadLocalInfo : Ptr32 Void
   +0x6cc Win32ClientInfo  : [62] Uint4B
   +0x7c4 glDispatchTable  : [233] Ptr32 Void
   +0xb68 glReserved1      : [29] Uint4B
   +0xbdc glReserved2      : Ptr32 Void
   +0xbe0 glSectionInfo    : Ptr32 Void
   +0xbe4 glSection        : Ptr32 Void
   +0xbe8 glTable          : Ptr32 Void
   +0xbec glCurrentRC      : Ptr32 Void
   +0xbf0 glContext        : Ptr32 Void
   +0xbf4 LastStatusValue  : Uint4B
   +0xbf8 StaticUnicodeString : _UNICODE_STRING
   +0xc00 StaticUnicodeBuffer : [261] Uint2B
   +0xe0c DeallocationStack : Ptr32 Void
   +0xe10 TlsSlots         : [64] Ptr32 Void
   +0xf10 TlsLinks         : _LIST_ENTRY
   +0xf18 Vdm              : Ptr32 Void
   +0xf1c ReservedForNtRpc : Ptr32 Void
   +0xf20 DbgSsReserved    : [2] Ptr32 Void
   +0xf28 HardErrorsAreDisabled : Uint4B
   +0xf2c Instrumentation  : [16] Ptr32 Void
   +0xf6c WinSockData      : Ptr32 Void
   +0xf70 GdiBatchCount    : Uint4B
   +0xf74 InDbgPrint       : UChar
   +0xf75 FreeStackOnTermination : UChar
   +0xf76 HasFiberData     : UChar
   +0xf77 IdealProcessor   : UChar
   +0xf78 Spare3           : Uint4B
   +0xf7c ReservedForPerf  : Ptr32 Void
   +0xf80 ReservedForOle   : Ptr32 Void
   +0xf84 WaitingOnLoaderLock : Uint4B
   +0xf88 Wx86Thread       : _Wx86ThreadState
   +0xf94 TlsExpansionSlots : Ptr32 Ptr32 Void
   +0xf98 ImpersonationLocale : Uint4B
   +0xf9c IsImpersonating  : Uint4B
   +0xfa0 NlsCache         : Ptr32 Void
   +0xfa4 pShimData        : Ptr32 Void
   +0xfa8 HeapVirtualAffinity : Uint4B
   +0xfac CurrentTransactionHandle : Ptr32 Void
   +0xfb0 ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME
   +0xfb4 SafeThunkCall    : UChar
   +0xfb5 BooleanSpare     : [3] UChar

TEB的0x30位置，有个PEB，每个进程都有这样一个结构体，想找PEB，就用TEB+0x30
kd> dt _PEB
ntdll!_PEB
   +0x000 InheritedAddressSpace : UChar
   +0x001 ReadImageFileExecOptions : UChar
   +0x002 BeingDebugged    : UChar
   +0x003 SpareBool        : UChar
   +0x004 Mutant           : Ptr32 Void
   +0x008 ImageBaseAddress : Ptr32 Void
   +0x00c Ldr              : Ptr32 _PEB_LDR_DATA
   +0x010 ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS
   +0x014 SubSystemData    : Ptr32 Void
   +0x018 ProcessHeap      : Ptr32 Void
   +0x01c FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION
   +0x020 FastPebLockRoutine : Ptr32 Void
   +0x024 FastPebUnlockRoutine : Ptr32 Void
   +0x028 EnvironmentUpdateCount : Uint4B
   +0x02c KernelCallbackTable : Ptr32 Void
   +0x030 SystemReserved   : [1] Uint4B
   +0x034 AtlThunkSListPtr32 : Uint4B
   +0x038 FreeList         : Ptr32 _PEB_FREE_BLOCK
   +0x03c TlsExpansionCounter : Uint4B
   +0x040 TlsBitmap        : Ptr32 Void
   +0x044 TlsBitmapBits    : [2] Uint4B
   +0x04c ReadOnlySharedMemoryBase : Ptr32 Void
   +0x050 ReadOnlySharedMemoryHeap : Ptr32 Void
   +0x054 ReadOnlyStaticServerData : Ptr32 Ptr32 Void
   +0x058 AnsiCodePageData : Ptr32 Void
   +0x05c OemCodePageData  : Ptr32 Void
   +0x060 UnicodeCaseTableData : Ptr32 Void
   +0x064 NumberOfProcessors : Uint4B
   +0x068 NtGlobalFlag     : Uint4B
   +0x070 CriticalSectionTimeout : _LARGE_INTEGER
   +0x078 HeapSegmentReserve : Uint4B
   +0x07c HeapSegmentCommit : Uint4B
   +0x080 HeapDeCommitTotalFreeThreshold : Uint4B
   +0x084 HeapDeCommitFreeBlockThreshold : Uint4B
   +0x088 NumberOfHeaps    : Uint4B
   +0x08c MaximumNumberOfHeaps : Uint4B
   +0x090 ProcessHeaps     : Ptr32 Ptr32 Void
   +0x094 GdiSharedHandleTable : Ptr32 Void
   +0x098 ProcessStarterHelper : Ptr32 Void
   +0x09c GdiDCAttributeList : Uint4B
   +0x0a0 LoaderLock       : Ptr32 Void
   +0x0a4 OSMajorVersion   : Uint4B
   +0x0a8 OSMinorVersion   : Uint4B
   +0x0ac OSBuildNumber    : Uint2B
   +0x0ae OSCSDVersion     : Uint2B
   +0x0b0 OSPlatformId     : Uint4B
   +0x0b4 ImageSubsystem   : Uint4B
   +0x0b8 ImageSubsystemMajorVersion : Uint4B
   +0x0bc ImageSubsystemMinorVersion : Uint4B
   +0x0c0 ImageProcessAffinityMask : Uint4B
   +0x0c4 GdiHandleBuffer  : [34] Uint4B
   +0x14c PostProcessInitRoutine : Ptr32     void 
   +0x150 TlsExpansionBitmap : Ptr32 Void
   +0x154 TlsExpansionBitmapBits : [32] Uint4B
   +0x1d4 SessionId        : Uint4B
   +0x1d8 AppCompatFlags   : _ULARGE_INTEGER
   +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER
   +0x1e8 pShimData        : Ptr32 Void
   +0x1ec AppCompatInfo    : Ptr32 Void
   +0x1f0 CSDVersion       : _UNICODE_STRING
   +0x1f8 ActivationContextData : Ptr32 Void
   +0x1fc ProcessAssemblyStorageMap : Ptr32 Void
   +0x200 SystemDefaultActivationContextData : Ptr32 Void
   +0x204 SystemAssemblyStorageMap : Ptr32 Void
   +0x208 MinimumStackCommit : Uint4B
PEB中有三个链表：在_PEB_LDR_DATA中
kd> dt _PEB_LDR_DATA
ntdll!_PEB_LDR_DATA
   +0x000 Length           : Uint4B
   +0x004 Initialized      : UChar
   +0x008 SsHandle         : Ptr32 Void
   +0x00c InLoadOrderModuleList : _LIST_ENTRY  //模块加载顺序
   +0x014 InMemoryOrderModuleList : _LIST_ENTRY //模块在内存中的顺序
   +0x01c InInitializationOrderModuleList : _LIST_ENTRY //所有模块初始化顺序
   +0x024 EntryInProgress  : Ptr32 Void

如果我想知道你程序有哪些模块，我就可以找到TEB，再找到PET，再找到_PEB_LDR_DATA，遍历读取这三个链表。隐藏模块，就是隐藏这些链表，把原来的A->B->C,变成A->C，B就隐藏起来了。但是程序不受影响，因为已经加载了，但是查询进程模块的API会受影响，B他查不到了，但是对于0环，这种隐藏是无效的。

驱动程序也有一套这样的链表：
kd> dt _DRIVER_OBJECT
ntdll!_DRIVER_OBJECT
   +0x000 Type             : Int2B
   +0x002 Size             : Int2B
   +0x004 DeviceObject     : Ptr32 _DEVICE_OBJECT
   +0x008 Flags            : Uint4B
   +0x00c DriverStart      : Ptr32 Void
   +0x010 DriverSize       : Uint4B
   +0x014 DriverSection    : Ptr32 Void
   +0x018 DriverExtension  : Ptr32 _DRIVER_EXTENSION
   +0x01c DriverName       : _UNICODE_STRING
   +0x024 HardwareDatabase : Ptr32 _UNICODE_STRING
   +0x028 FastIoDispatch   : Ptr32 _FAST_IO_DISPATCH
   +0x02c DriverInit       : Ptr32     long 
   +0x030 DriverStartIo    : Ptr32     void 
   +0x034 DriverUnload     : Ptr32     void 
   +0x038 MajorFunction    : [28] Ptr32     long 

在+0x014偏移位置，有个DriverSection，是void类型，其实是一个结构体_LDR_DATA_TABLE_ENTRY:
kd> dt _LDR_DATA_TABLE_ENTRY
ntdll!_LDR_DATA_TABLE_ENTRY
   +0x000 InLoadOrderLinks : _LIST_ENTRY  //加载顺序（有用）
   +0x008 InMemoryOrderLinks : _LIST_ENTRY  //内存顺序（驱动中是空的，无用）
   +0x010 InInitializationOrderLinks : _LIST_ENTRY //模块初始化顺序（驱动中是空的，无用）
   +0x018 DllBase          : Ptr32 Void //当前模块从哪里开始的
   +0x01c EntryPoint       : Ptr32 Void //入口点
   +0x020 SizeOfImage      : Uint4B //模块大小
   +0x024 FullDllName      : _UNICODE_STRING //模块路径
   +0x02c BaseDllName      : _UNICODE_STRING //模块名称
   +0x034 Flags            : Uint4B
   +0x038 LoadCount        : Uint2B
   +0x03a TlsIndex         : Uint2B
   +0x03c HashLinks        : _LIST_ENTRY
   +0x03c SectionPointer   : Ptr32 Void
   +0x040 CheckSum         : Uint4B
   +0x044 TimeDateStamp    : Uint4B
   +0x044 LoadedImports    : Ptr32 Void
   +0x048 EntryPointActivationContext : Ptr32 Void
   +0x04c PatchInformation : Ptr32 Void

内核编程基础
未文档化函数、未导出函数
未文档化就是WDK文档里搜不到，但是在导出表里的函数，要使用这种函数可以使用GetProcAddress函数获取函数地址；
未导出函数就是不在导出表的函数，可以通过特征码搜索或者解析内核PDB的方式找到函数地址，通过函数指针调用。

DK数据类型
WDK数据类型在ntdef.h中定义，下面列举部分，注意，并没有UINT
typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;

NTSTATUS 返回值
很多内核函数的返回值都是 NTSTATUS，这是一个4字节整型。
STATUS_SUCCESS		0x00000000	成功		
STATUS_INVALID_PARAMETER	0xC000000D	参数无效	
STATUS_BUFFER_OVERFLOW	0x80000005	缓冲区长度不够

内核异常处理
在内核中，一个小小的错误就可能导致蓝屏，比如：读写一个无效的内存地址。为了让自己的内核程序更加健壮，强烈建议大家在编写内核程序时，使用异常处。
Windows提供了结构化异常处理机制，一般的编译器都是支持的，如下：
__try{
	//可能出错的代码
}
__except(filter_value) {
	//出错时要执行的代码
}
出现异常时，可根据filter_value的值来决定程序该如果执行，当filter_value的值为：
EXCEPTION_EXECUTE_HANDLER(1)，代码进入except块
EXCEPTION_CONTINUE_SEARCH(0)，不处理异常，由上一层调用函数处理
EXCEPTION_CONTINUE_EXECUTION(-1)，回去继续执行错误处的代码
演示：
__try
{
	PULONG ptr = NULL;
	*ptr = 0x1234;
}
__except(EXCEPTION_EXECUTE_HANDLER)
{		
	DbgPrint("非法访问内存.\r\n");
}

常用的内核内存函数
C语言	内核
malloc	ExAllocatePool
memset	RtlFillMemory
memcpy	RtlMoveMemory
free	ExFreePool

内核字符串及常用字符串函数
为了提高安全性，内核中的字符串不再是字符串首地址指针作为开始，0作为结尾，而是采用了以下两个结构体：
ANSI_STRING字符串：
typedef struct _STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
}STRING;
UNICODE_STRING字符串：
typedef struct _UNICODE_STRING
{
    USHORT Length;
    USHORT MaxmumLength;
    PWSTR Buffer;
} UNICODE_STRING;
下面的表格列出了常用的字符串函数：

功能	ANSI_STRING字符串               UNICODE_STRING字符串
创建	RtlInitAnsiString	            RtlInitUnicodeString
复制	RtlCopyString	                RtlCopyUnicodeString
比较	RtlCompareString	            RtlCompareUnicoodeString
转换	RtlAnsiStringToUnicodeString	RtlUnicodeStringToAnsiString

课后练习
申请一块内存，并在内存中存储GDT、IDT的所有数据。然后在debugview中显示出来，最后释放内存。
#include <ntddk.h>
#include <ntdef.h>

// 卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	DbgPrint("驱动程序停止运行了.\r\n");	
}

// 入口函数，相当于main
NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)
{	
	UCHAR GDT[6];
	UCHAR IDT[6];
	ULONG GdtAddr,GdtLen,IdtAddr,IdtLen;
	PUCHAR pBuffer = NULL;
	ULONG i;
	// 设置一个卸载函数，便于退出
	driver->DriverUnload = DriverUnload;
	// 读取GDT, IDT
	__asm
	{
		sgdt fword ptr GDT
		sidt fword ptr IDT
	}
	GdtAddr = *(PULONG)(GDT+2);
	GdtLen = *(PUSHORT)GDT;
	IdtAddr = *(PULONG)(IDT+2);
	IdtLen = *(PUSHORT)IDT;
	// DbgPrint("GDT: %08X size: %04X\r\n", GdtAddr, GdtLen);
	// DbgPrint("IDT: %08X size: %04X\r\n", IdtAddr, IdtLen);
	// 申请内存
	pBuffer = (PUCHAR)ExAllocatePool(PagedPool, GdtLen + IdtLen);
	// 检查申请是否成功
	if (NULL == pBuffer)
	{
		DbgPrint("申请内存失败.\r\n");
		return STATUS_UNSUCCESSFUL;
	}
	// 拷贝GDT, IDT数据
	RtlMoveMemory(pBuffer, (PUCHAR)GdtAddr, GdtLen);
	RtlMoveMemory(pBuffer + GdtLen, (PUCHAR)IdtAddr, IdtLen);
	// 打印数据
	DbgPrint("打印GDT\r\n");
	for (i = 0; i < GdtLen; i += 16)
	{
		DbgPrint("%08X  %08X %08X %08X %08X\r\n", GdtAddr + i, ((PULONG)(GdtAddr + i))[0],((PULONG)(GdtAddr + i))[1],((PULONG)(GdtAddr + i))[2],((PULONG)(GdtAddr + i))[3]);
	}
	DbgPrint("打印IDT\r\n");
	for (i = 0; i < IdtLen; i += 16)
	{
		DbgPrint("%08X  %08X %08X %08X %08X\r\n", IdtAddr + i, ((PULONG)(IdtAddr + i))[0],((PULONG)(IdtAddr + i))[1],((PULONG)(IdtAddr + i))[2],((PULONG)(IdtAddr + i))[3]);
	}
	// 释放内存
	ExFreePool(pBuffer);		
	
	return STATUS_SUCCESS;
}
编写代码，实现如下功能：
<1> 初始化一个字符串
<2> 拷贝一个字符串
<3> 比较两个字符串是否相等
<4> ANSI_STRING与UNICODE_STRING字符串相互转换
不知为何，Unicode字符串中如果有中文，dbgview和windbg打印出来是空白。
#include <ntddk.h>
#include <ntdef.h>

// 卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	DbgPrint("驱动程序停止运行了.\r\n");	
}

// 入口函数，相当于main
NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)
{	
	// 创建字符串
	ANSI_STRING AnsiSrc;
	ANSI_STRING AnsiDst;
	UNICODE_STRING UnicodeString;
	// 初始化字符串	
	RtlInitAnsiString(&AnsiSrc,"my first ANSI_STRING");
	RtlInitUnicodeString(&UnicodeString,L"my first UNICODE_STRING");
	// 打印字符串
	DbgPrint("%s Length: %d MaximumLength: %d\r\n", AnsiSrc.Buffer, AnsiSrc.Length, AnsiSrc.MaximumLength);
	DbgPrint("%ws Length: %d MaximumLength: %d\r\n", UnicodeString.Buffer, UnicodeString.Length, UnicodeString.MaximumLength);
	// 拷贝字符串
	RtlCopyString(&AnsiDst, &AnsiSrc);
	// 比较字符串
	if (RtlCompareString(&AnsiSrc, &AnsiDst, TRUE) == 0)
	{
		DbgPrint("字符串相等.\r\n");
	}
	else
	{
		DbgPrint("字符串不相等.\r\n");
	}
	// Unicode转Ansi
	DbgPrint("Unicode转Ansi\r\n");
	RtlUnicodeStringToAnsiString(&AnsiDst,&UnicodeString,TRUE);	
	DbgPrint("%s Length: %d MaximumLength: %d\r\n", AnsiDst.Buffer, AnsiDst.Length, AnsiDst.MaximumLength);
	// 设置一个卸载函数，便于退出
	driver->DriverUnload = DriverUnload;
	return STATUS_SUCCESS;
}

