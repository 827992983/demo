 JMP 0x20:0x004183D7
上面是一条 JMP FAR 指令，FAR根据地址格式自动添加，如果是：JMP 0x004183D7就只修改EIP，如果是 JMP 0x20:0x004183D7就同时修改CS和EIP，查不查表是由指令格式决定的，0x20就是段选择子，通过段选择子的index查GDT的gdt[index]获取段描述符，CPU执行该指令分为以下5步：

(1)拆分段选择子
0x20 = 00100 0 00
RPL = 0
TI = 0
INDEX = 4

(2)查GDT表得到段描述符
根据段选择子拆得的下标，找到GDT表第5项。如果P=1，S=1，TYPE高1位=1，则表明这是一个代码段，就可以进行下一步。

(3)权限检查
TYPE域高2位是C属性，C=0表示非一致代码段，C=1表示一致代码段。
如果是非一致代码段，要求:CPL == DPL 并且 RPL <= DPL；
如果是一致代码段，要求:CPL >= DPL。

(4)加载段描述符
通过上面的权限检查后，CPU会将段描述符加载到CS段寄存器中。

(5)执行代码
CPU将 CS.Base + Offset 的值写入EIP 然后执行CS:EIP处的代码，段间跳转结束。


总结：
(1)对于一致代码段：也就是共享的段
特权级别高的程序不允许访问特权级别低的数据：核心态不允许访问用户态的数据
特权级别低的程序可以访问到特权级别高的数据，但特权级别不会改变：系统调用，用户态还是用户态
(2)对于普通代码段：也就是非一致代码段，(windows只使用了非一致代码段)
只允许同级访问
绝对禁止不同级别的访问：核心态不允许访问用户态，用户态也不允许访问核心态
(3)直接对代码段进行JMP或者CALL的操作，无论目标是一直代码段还是非一致代码段，CPL都不会发生改变，如果要提升CPL的权限，只能通过调用门
