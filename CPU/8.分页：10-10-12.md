逻辑地址，也有称作有效地址的。就是你在写 C 语言代码的时候，用到的指针里存的地址。
线性地址，如果你还记得段选择子结构的话，其中有一个成员是 base，表示段基址。那么线性地址=ds.base+逻辑地址。（以 ds 段寄存器为例）
物理地址，通过某种映射方法，把线性地址映射到真实的物理内存上的某个地址上。说的通俗点，就是通过一种计算方法，把线性地址当作参数，传到一个函数里，经过一通折腾，返回来一个新的地址，这个新的地址就是物理地址，是真实的位于物理内存上的地址。
实际上，最终计算的物理地址并不是真的就是真实物理内存条上的地址，物理地址到真实内存条还有一层关系，然而对于我们来说，理解到这一层次足够了，简单说一句，CPU会把内存条、显卡、网卡等设备统一编址（物理地址）。

mov eax,dword ptr ds:[0x12345678]
这条mov指令中，0x12345678 是有效地址，ds.base+0x12345678是线性地址。

页
页是CPU的一种机制，说白了，页就是一块内存，你现在可以这么简单理解。
问题是这个固定大小，到底是多大？CPU提供了两种大小，一种是 4KB（2的12次方，也就是0x1000）大小的内存块，称之为小页面，还有一种是大页。

为了能够方便使用内存，CPU 把4GB地址空间（0x00000000~0xffffffff）划分成了2^20（2的20次方）个，也就是1MB个固定大小的内存块，每一块的大小都是 0x1000 字节。第 0 页的范围是 0x0000000~0x00000fff，第二页的范围是0x00001000~0x00001fff ......

线性地址到物理地址的映射
CPU把物理地址空间分成了若干个小页面（4KB），每个小页面都给了它一个编号，比如从编号从0 ~ 2^20 -1，（假设我的物理内存就是4GB）。写成 16 进制就是从 0x00000~0xfffff。这样，每个编号其实占用了 20 个比特位。
如果你的物理内存只有 1MB，可以分割成2^8个小页面，那编号就是从 0-2^8-1，16进制就是0x00000~0x000ff。

只要知道到了小页面的编号，就一定能够计算出这些小页面的真实物理地址。比如 0 号物理页的物理地址就是 0x00000000，1 号物理页的地址是 0x00001000，0x000ff号的物理地址就是0x000ff000。这种计算方法很简单，只要把页面编号乘以 4KB 就行了，也就是乘以 4096，或者说左移 12 位，效果都是一样，因为每个小页面大小都是 4096 字节。

为了能让 CPU 找到这些小页面，势必要把这些小页面的“门牌号”保存起来。同样，这些“门牌号”也要保存在物理内存中，为了方便管理，再从物理内存中取出一页，来保存这些大小为 20 bit 的门牌号。

CPU 用 32 bit (4字节)来保存一个页面编号，其中高20 bit 保存编号，低12位保存页面属性。目前你还不用关心这多出来的 12 bit 保存了啥属性。我们只关心其中的 20 bit 编号。

如此一来，一页可以保存4KB/4B = 1024个“门牌号”

我们把保存这种门牌号的页，称之为页表。而页表中的每一个元素占用4字节。一个页表可以保存1024个元素。如果用数组来表示页表，就是这样的

int page_tables[1024]

线性地址转换成物理地址
一级页表（PDT）、二级页表（PTT）和普通物理页
那些保存普通物理页索引号的页表，称为二级页表，而保存页表索引号的页表，称为一级页表，也叫页目录表。如图5。图中的 PDE意思是 page directory entry，即页目录表项；PTE的意思是 page table entry，即页表项。

线性地址 10-10-12 分页
线性地址中保存的，就是页表中的索引号，也就是前面说的门牌号。一个线性地址是32位，它的结构是这样的。
|   31~22  |  21~12   |    11~0    | 比特
|9876543210|9876543210|ba9876543210| 比特
|----------|----------|------------| 占位
| 一级索引 | 二级索引 |  页内偏移  | 说明

例：有线性地址 0x12345678，对应到上面的结构就是这样的。

|   31~22  |  21~12   |    11~0    | 比特
|9876543210|9876543210|ba9876543210| 比特
|----------|----------|------------| 占位
| 一级索引 | 二级索引 |  页内偏移  | 说明
|0001001000|1101000101|011001111000| <-- 线性地址0x12345678做 10-10-12 拆分
于是我们得到第一个页表索引号，它是 0001001000 = 0x48
第二个页表的索引号，它是 1101000101 = 0x345
最后一个是页内偏移，它是 011001111000 = 0x678
假如我们已经知道一级页表（这个通常称之为页目录）的基址page_dir_tables.实际上在CPU中，有一个寄存器，称之为 CR3 寄存器（CR3里面存的值是物理地址），它保存了一级页表的基址。
那么根据一级索引，我们得到 page_dir_tables[0x48] 的值，假设 page_dir_tables[0x48] = 0x12fff067
页表中每一项的高20位保存的都是另一个物理页的编号。根据规则，0x12fff067 的高20位是二级页表编号，即0x12fff，于是计算得到这个物理页基址是0x12fff000.
为了能找到这一页中索引号 0x345 这个位置的值，令 int *page_tables = 0x12fff000， page_tables[0x345]=0x21991067，那么这个值中告诉我们的页编号是 0x21991，换算成页基址是 0x21991000。
最终我们定向到了物理页 0x21991000，这个物理页保存的也不是页面编号了，就是普通数据，它是普通页。线性地址的第 3 部分，是页内偏移，把这个普通页的基址+页内偏移，最终得到了物理地址，也就是 0x21991000+0x678=0x21991678。

总结
本篇简单介绍了 10-10-12 分页，一个线性地址按照10-10-12分成三段：
第一段，一级页表索引号
第二段，二级页表索引号
第三段，普通页页内偏移

实验
修改操作系统启动项改成10-10-12分页模式，把debug模式的noexecute改成execute
[boot loader]
timeout=5
default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS
[operating systems]
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Microsoft Windows XP Professional" /noexecute=optin /fastdetect
multi(0)disk(0)rdisk(0)partition(1)\WINDOWS="Microsoft Windows XP Professional" /execute=optin /fastdetect /debug /debugport=com2
C:\GHLDR=一键GHOST v2014.01.14


实验代码
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    char buf[] = "hello world! I'm in linear address convertion experiment!";
    char *p = (char*)malloc(strlen(buf)+1);
    strcpy(p, buf);
    printf("%s\n", p);
    printf("%08x\n", p);
    getchar();
    free(p);
    return 0;
}

编译并运行
线性地址：00430040
拆分：0000 0000 01    00 0011 0000     0000 0100 0000
0x1 0x30 0x40

在虚拟机中编译以上代码，运行。这时候会在 getchar()处停下来，然后不要回车，在 WinDbg 中中断下来。

kd> !process 0 0
Failed to get VadRoot
PROCESS 85ee8818  SessionId: 0  Cid: 077c    Peb: 7ffd8000  ParentCid: 076c
    DirBase: 14933000  ObjectTable: e1b3c140  HandleCount:  12.
    Image: test.exe


DirBase: 14933000 ，则 CR3=14933000就是第一张表首地址
下标是：0x1，第一和第二张表存的是地址，大小是4字节，所以要乘4，则第一组表位置为：14933000+0x1*4 = 14933004

kd> !dd 14933004
#14933004 147c1067 00000000 00000000 00000000
#14933014 00000000 00000000 00000000 00000000
#14933024 00000000 00000000 00000000 00000000
#14933034 00000000 00000000 00000000 00000000
#14933044 00000000 00000000 00000000 00000000
#14933054 00000000 00000000 00000000 00000000
#14933064 00000000 00000000 00000000 00000000
#14933074 00000000 00000000 00000000 00000000

查表得出：147c1067

页表中的每个元素的高20位是用来存储页表编号的，所以这里二级页表的编号应该是 147c1，后面的 067 只是 147c1 号页面的属性。
根据运算规则，可以计算出二级页表的基址为 147c1000(因为每个页大小是 4KB)。故有二级页表地址：147c1000.
第二张表的索引是：0x30，第二张表地址就是 147c1000。第二个下标0x30，乘以4后就是c0，还是使用!dd查看物理内存：!dd 147c10c0
kd> !dd 147c10c0
#147c10c0 150ad067 14f2e067 146ef067 14830067
#147c10d0 148b1067 147b2067 14973067 146b4067
#147c10e0 00000000 00000000 00000000 00000000
#147c10f0 00000000 00000000 00000000 00000000
#147c1100 00000000 00000000 00000000 00000000
#147c1110 00000000 00000000 00000000 00000000
#147c1120 00000000 00000000 00000000 00000000
#147c1130 00000000 00000000 00000000 00000000

查表得出：150ad067
依据规则，我们得到该保存的页面编号的值是 150ad，于是计算得到这个页的页基址是 150ad000，这只是一个普通页，用来保存数据的。
150ad000 + 0x40 = 150ad040 （0x40就是偏移地址，不需要在乘以4了，我做实验的时候就烦了这个错误）
    
kd> !db 150ad040
#150ad040 68 65 6c 6c 6f 20 77 6f-72 6c 64 21 20 49 27 6d hello world! I'm
#150ad050 20 69 6e 20 6c 69 6e 65-61 72 20 61 64 64 72 65  in linear addre
#150ad060 73 73 20 63 6f 6e 76 65-72 74 69 6f 6e 20 65 78 ss convertion ex
#150ad070 70 65 72 69 6d 65 6e 74-21 00 fd fd fd fd 00 00 periment!.......
#150ad080 00 00 00 00 00 00 00 00-71 00 00 00 41 00 00 00 ........q...A...
#150ad090 d0 00 43 00 68 49 38 00-f0 0b 42 00 79 00 00 00 ..C.hI8...B.y...
#150ad0a0 12 00 00 00 02 00 00 00-27 00 00 00 fd fd fd fd ........'.......
#150ad0b0 5f 4d 53 44 45 56 5f 42-4c 44 5f 45 4e 56 5f 3d _MSDEV_BLD_ENV_=


总结

每个进程：第一级一张表，第二级1024张表
每个进程一套页表，进程切换时，CR3寄存器里面的值会替换成当前进程的CR3值
进程就是为了提供一个CR3值，他里面所有线程的CR3值都是一个，现在你应该理解操作系统里面讲的进程是资源分配的最小单位，线程是自研调度的最小单位。

思考：
1.就算CR3里面存的是物理地址，我们程序也无法使用物理地址，那么到底怎么访问读写CR3呢？
答：一定有一个线性地址指向一个物理地址。PDT、PTT物理地址也一样，也有对应的线性地址。可以通过拆分实验论证。
2.那么CR3是给谁用的呢？
答：是给CPU用的，A线程被调度执行的时候，CPU会通过CR3寄存器里面的物理地址查表（线程切换时候，会换一对寄存器），找到A线程的物理地址。
3.我可以改CR3吗？
答：可以，远程进程调用OpenProcess，就是把别人的CR3复制到了自己的进程空间，那么此时，我使用的线性地址，如：变量a，那么也是别人（被打开进程）的线性地址了。
4.0xC0300000线性地址，就是PDT的线性地址，论证：
1100 0000 00    11 0000 0000     0000 0000 0000
一级偏移：300 * 4 = c00
二级偏移：300 * 4 = c00
三级偏移：0

kd> !process 0 0
Failed to get VadRoot
PROCESS 864c3ac0  SessionId: 0  Cid: 00d0    Peb: 7ffd6000  ParentCid: 0320
    DirBase: 1d46d000  ObjectTable: e28b06a8  HandleCount:  12.
    Image: test.exe

kd> !dd 1d46d000+c00
#1d46dc00 1d46d063 1d62e063 00000000 06a56163
#1d46dc10 06a57163 06a58163 06a59163 06a5a163
#1d46dc20 06a5b163 06a5c163 06a5d163 06a5e163
#1d46dc30 06a5f163 06a60163 06a61163 06a62163
#1d46dc40 06a63163 06a64163 06a65163 06a26163
#1d46dc50 06a27163 06a28163 06a29163 06a2a163
#1d46dc60 06a2b163 06a2c163 06a2d163 06a2e163
#1d46dc70 06a2f163 06a30163 06a31163 06a32163
kd> !dd 1d46d000+c00
#1d46dc00 1d46d063 1d62e063 00000000 06a56163
#1d46dc10 06a57163 06a58163 06a59163 06a5a163
#1d46dc20 06a5b163 06a5c163 06a5d163 06a5e163
#1d46dc30 06a5f163 06a60163 06a61163 06a62163
#1d46dc40 06a63163 06a64163 06a65163 06a26163
#1d46dc50 06a27163 06a28163 06a29163 06a2a163
#1d46dc60 06a2b163 06a2c163 06a2d163 06a2e163
#1d46dc70 06a2f163 06a30163 06a31163 06a32163
kd> !dd 1d46d000
#1d46d000 1d4a4067 1d6e3067 00000000 00000000
#1d46d010 00000000 00000000 00000000 00000000
#1d46d020 00000000 00000000 00000000 00000000
#1d46d030 00000000 00000000 00000000 00000000
#1d46d040 00000000 00000000 00000000 00000000
#1d46d050 00000000 00000000 00000000 00000000
#1d46d060 00000000 00000000 00000000 00000000
#1d46d070 00000000 00000000 00000000 00000000 //对应的物理页

我发发现1：这个物理页很神奇，他又是PDT又是PTT

我们发现2：DirBase: 1d46d000和我们使用0xC0300000线性地址找到的物理页，就是一个页，通过0xC0300000线性地址能改任意地址的PDE
那么我们就可以通过0xC0300000线性地址来挂物理页：mov dword ptr ds:[0xC0300000 + x*4] //x就是你想挂的物理页，这就是通过程序挂物理页，但是3环肯定不能访问这个地址，需要驱动实现。
mov dword ptr ds:[0xC0300000 + x*4], 0x12345678 //修改索引x处的PDE为0x12345678
mov dword ptr ds:[0xC0300000], 0x12345678 //修改的是0地址的PTE


0xC0000000
1100 0000 0000 0000 0000 0000 0000 0000
一级偏移：300 * 4 = c00
二级偏移：0 * 4 = 0
三级偏移：0

kd>  !dd 1d46d000+c00
#1d46dc00 1d46d063 1d62e063 00000000 06a56163
#1d46dc10 06a57163 06a58163 06a59163 06a5a163
#1d46dc20 06a5b163 06a5c163 06a5d163 06a5e163
#1d46dc30 06a5f163 06a60163 06a61163 06a62163
#1d46dc40 06a63163 06a64163 06a65163 06a26163
#1d46dc50 06a27163 06a28163 06a29163 06a2a163
#1d46dc60 06a2b163 06a2c163 06a2d163 06a2e163
#1d46dc70 06a2f163 06a30163 06a31163 06a32163
kd> !dd 1d46d000
#1d46d000 1d4a4067 1d6e3067 00000000 00000000
#1d46d010 00000000 00000000 00000000 00000000
#1d46d020 00000000 00000000 00000000 00000000
#1d46d030 00000000 00000000 00000000 00000000
#1d46d040 00000000 00000000 00000000 00000000
#1d46d050 00000000 00000000 00000000 00000000
#1d46d060 00000000 00000000 00000000 00000000
#1d46d070 00000000 00000000 00000000 00000000
kd> !dd 1d4a4000
#1d4a4000 00000000 00000000 00000000 00000000
#1d4a4010 00000000 00000000 00000000 00000000
#1d4a4020 00000000 00000000 00000000 00000000
#1d4a4030 00000000 00000000 00000000 00000000
#1d4a4040 1d8e5067 00000000 00000000 00000000
#1d4a4050 00000000 00000000 00000000 00000000
#1d4a4060 00000000 00000000 00000000 00000000
#1d4a4070 00000000 00000000 00000000 00000000

通过实验：通过0xC0000000线性地址可以修改任意PTE

实验总结：
线性地址是连续的，物理地址是不连续的（可以拆：0xC0000000,0xC0001000进行验证）
线性地址0xC0300000  页目录PDT线性地址  通过0xC0300000线性地址能改任意地址的PDE
线性地址0xC0000000  页表PTT线性地址    通过0xC0000000线性地址能改任意地址的PTE，就是0xC0300000第一个PDE
有了这两个地址，我们可以操作任意进程的物理页，有公式：
线性地址：0xC0300000 + x*4 就可以访问页目录表PDT索引x项
线性地址：0xC0000000 + x*4096 + y*4 就可以访问也页表PTT索引y项
逆向操作系统函数：MmIsAddressValid ，可以发现操作系统是如何判断一个线性内存地址是否有效的

换一种说法：
如果一个线性地址被拆分成三段式PDI-PTI-OFFSET，则有：
PDE 的基址：PDT[PDI] = 0xc0300000 + PDI * 4     // 第 PDI 个 PDE 的基址
PTE 的基址：PTE[PTI] = 0xc0000000 + PDI * 4096 + PTI*4     // 第 PDI 个 PDE 指向的 PTT 中的第 PTI 个 PTE 的基址



打个比喻：内存就是一本书，每个进程有自已一套目录，自己查自己的目录

物理内存有2类：一类是共有的（全局变量，map到物理内存）一类是私有的（堆栈内存，局部变量或malloc的内存）

保护模式是CPU的模式，在应用程序中永远的不到物理地址，物理地址是给CPU用的，不要妄想去直接读写物理地址。只有刚启动的时候，CPU还在实模式，那时候可以访问物理内存地址，一旦启动代码将CPU模式设置为保护模式，以后再访问物理内存就必须查表。





