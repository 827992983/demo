页、页索引号、页表、页目录
页：物理内存中固定大小（4KB）的连续内存块。必须以4KB对齐划分。
页索引号：把物理内存中的页挨个编号，从 0 开始，一直到最后一页。如果是物理内存只有40KB大小，最后一页的索引号就是 9。页索引号占用 20 bit。
页表：一个大小为 1024 个元素的数组，用来保存页索引号。数组中的每个元素的高20 bit 用来保存页索引号，低 12 bit 保存页属性。每个元素的大小是 32 bit，也就是 4 字节。一个页表本身占用一页（4KB）
页目录：页表本身既然也占用一页，那页表本身这个物理页也是有索引号的。所以保存这种物理页索引号的页表，叫一级页表，也叫页目录。

PDE 是页目录表项。而 PTE是页表表项。

PDE 结构
|<------ 31~12------>|<------ 11~0 --------->| 比特
                     |b a 9 8 7 6 5 4 3 2 1 0| 
|--------------------|-|-|-|-|-|-|-|-|-|-|-|-| 占位
|<-------index------>| AVL |G|P|0|A|P|P|U|R|P| 属性
                             |S|   |C|W|/|/|
                                   |D|T|S|W|

PTE 结构
|<------ 31~12------>|<------ 11~0 --------->| 比特
                     |b a 9 8 7 6 5 4 3 2 1 0|
|--------------------|-|-|-|-|-|-|-|-|-|-|-|-| 占位
|<-------index------>| AVL |G|P|D|A|P|P|U|R|P| 属性
                             |A|   |C|W|/|/|
                             |T|   |D|T|S|W|

属性含义（除了bit6，bit7位，其他都一样）
P：有效位。0 表示当前表项无效。
R/W: 0 表示只读。1表示可读写。
U/S: 0 表示只能0、1、2特权级可访问。3 表示只有特权级程序可访问
A: 0 表示该页未被访问，1表示已被访问。
D: 脏位。0表示该页未写过，1表示该页被写过。
PS: 只存在于页目录表。0表示这是4KB页，指向一个页表。1表示这是4MB大页，直接指向物理页。
PWT、PCD、G：暂不讲解

10-10-12分页：
CR3=PDT首地址，PDT里面有1024项PDE（每个PDE有4字节）--->PDE里面每一项都是物理地址，前20bit是地址信息，指向了另外一个物理页（页表：PDT），后面12bit是属性。
PDE--->PTT首地址，PDT里面有1024项PTE（每个PTE有4字节）--->PTE里面每一项都是物理地址，前20bit是地址信息，指向了另外一个物理页（具体的物理页，也是4KB），后面12bit是属性。
1024*1024*4096=4GB

实验：挂物理页可以访问0地址

代码：
#include "stdafx.h"
#include <Windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    int x = 1; // 让NULL指向x所在的物理页
	printf("x的地址：%x\n", &x);
	getchar(); // 在windbg里修改NULL 的PTE
	// NULL不能读写，原因是PTE为0，即没有分配物理页
	// 所以只要给NULL的PTE分配物理页，就能读写NULL了	
	printf("NULL地址数据：%x\n",*(int*)NULL);
	*(int*)NULL = 0x112233;	
	printf("NULL地址数据：%x\n",*(int*)NULL); // 0x112233
	getchar(); 
	return 0;
}

变量x的线性地址：0012ff7c
0000 0000 00    01 0010 1111     1111 0111 1200
0 12f f7c

kd> !process 0 0
Failed to get VadRoot
PROCESS 8660dda0  SessionId: 0  Cid: 02e4    Peb: 7ffdb000  ParentCid: 05bc
    DirBase: 23ffc000  ObjectTable: e176c860  HandleCount:  12.
    Image: test.exe

CR3=23ffc000  

kd> !dd 23ffc000
#23ffc000 2413e067 241fd067 00000000 00000000
#23ffc010 00000000 00000000 00000000 00000000
#23ffc020 00000000 00000000 00000000 00000000
#23ffc030 00000000 00000000 00000000 00000000
#23ffc040 00000000 00000000 00000000 00000000
#23ffc050 00000000 00000000 00000000 00000000
#23ffc060 00000000 00000000 00000000 00000000
#23ffc070 00000000 00000000 00000000 00000000

2413e067 
2413e000 + 4*12f = 2413e4bc

kd> !dd 2413e4bc
#2413e4bc 24302067 113e1025 113a2025 00000000
#2413e4cc 00000000 00000000 00000000 00000000
#2413e4dc 00000000 00000000 00000000 00000000
#2413e4ec 00000000 00000000 00000000 00000000
#2413e4fc 00000000 24347067 243c8067 243cb067
#2413e50c 24479067 00000000 00000000 00000000
#2413e51c 00000000 00000000 00000000 00000000
#2413e52c 00000000 00000000 00000000 00000000


24302067    普通物理页

24302000 + f7c = 24302f7c
kd> !dd 24302f7c
#24302f7c 00000001 0012ffc0 00401639 00000001
#24302f8c 00430ea0 00430de0 00241fe4 0012f7bc
#24302f9c 7ffdb000 00000006 ee380d04 0012ff94
#24302fac 867ee074 0012ffe0 00406784 00420170
#24302fbc 00000000 0012fff0 7c816037 00241fe4
#24302fcc 0012f7bc 7ffdb000 8054c838 0012ffc8
#24302fdc 8660db20 ffffffff 7c839b48 7c816040
#24302fec 00000000 00000000 00000000 00401550


NULL = 0
拆分得：
0000 0000 ‭0000 0000 0000 0000 0000 0000
0 0 0

CR3都一样
kd> !dd 23ffc000
#23ffc000 2413e067 241fd067 00000000 00000000
#23ffc010 00000000 00000000 00000000 00000000
#23ffc020 00000000 00000000 00000000 00000000
#23ffc030 00000000 00000000 00000000 00000000
#23ffc040 00000000 00000000 00000000 00000000
#23ffc050 00000000 00000000 00000000 00000000
#23ffc060 00000000 00000000 00000000 00000000
#23ffc070 00000000 00000000 00000000 00000000


2413e067 
2413e000 + 4*0

kd> !dd 2413e000
#1d8e4000 00000000 00000000 00000000 00000000
#1d8e4010 00000000 00000000 00000000 00000000
#1d8e4020 00000000 00000000 00000000 00000000
#1d8e4030 00000000 00000000 00000000 00000000
#1d8e4040 1dc25067 00000000 00000000 00000000
#1d8e4050 00000000 00000000 00000000 00000000
#1d8e4060 00000000 00000000 00000000 00000000
#1d8e4070 00000000 00000000 00000000 00000000

用!ed指令改写成x的PTE 1d928067
!ed 2413e000 24302067

kd> !ed 2413e000 24302067
kd> !dd 2413e000
#2413e000 24302067 00000000 00000000 00000000
#2413e010 00000000 00000000 00000000 00000000
#2413e020 00000000 00000000 00000000 00000000
#2413e030 00000000 00000000 00000000 00000000
#2413e040 240ff067 00000000 00000000 00000000
#2413e050 00000000 00000000 00000000 00000000
#2413e060 00000000 00000000 00000000 00000000
#2413e070 00000000 00000000 00000000 00000000


页目录表PDT
0xc0300000 指向页目录表（PDT）
0xc0000000 指向第一张页表（PTT）
页目录表其实是一张特殊的页表，它是第0x300张页表。
页目录表中每项PTE都指向一张页表，其中第0x300项指向了页目录表自己。

页表PTT
页表总共有1024张，每张4KB，总共占了1024*4KB=4MB内存，1024张页表的线性地址是连续的，但物理地址不连续。
页表被映射到了从0xC0000000到0xC03FFFFF的4MB地址空间。
在这1024个页表中，第0x300个是一张特殊的表：页目录表。

我们知道了有一个线性地址 0xC0000000 指向了第一张页表，也知道了线性地址 0xC0300000 指向了页目录表，它其实是第0x300张页表。我们可以通过0xC0300000 找到任何一个线性地址的PDE，我们还知道1024张页表在内存中是连续的，这意味着我们可以通过 0xC0000000 找到任何一个 PTE。公式如下：

PDE = 0xC0300000 + PDI * 4
PTE = 0xC0000000 + PDI * 4KB + PTI * 4

PDI 是页目录表的下标，PTI是页表的下标，分别对应10-10-12的前两个10.
解释一下第二条公式，0xC0000000 + PDI * 4KB 是找到线性地址所在的页表，为什么可以这样做？因为页表的线性地址是连续的（但物理地址不连续），范围是 0xC0000000 - 0xC03FFFFF。
找到页表后，加上 PTI * 4 就能找到其页表项PTE了。

实验:给NULL挂一个物理页。10-10-12 分页

#include "stdafx.h"
#include <Windows.h>

typedef ULONG (WINAPI *DBGPRINT)(
  PCSTR Format,
  ...   
);

DBGPRINT DbgPrint = NULL;

DWORD *GetPDE(DWORD addr)
{
	DWORD PDI = addr>>22;
	DWORD PTI = (addr>>12)&0x000003FF;
	return (DWORD *)(0xC0300000 + PDI * 4);
}

DWORD *GetPTE(DWORD addr)
{
	DWORD PDI = addr>>22;
	DWORD PTI = (addr>>12)&0x000003FF;
	return (DWORD *)(0xC0000000 + PDI * 0x1000 + PTI * 4);
}

DWORD *page;

void __declspec(naked) R0Function()
{
	__asm
	{
		push ebp
		mov ebp,esp
		sub esp,0x1000
		pushad
		pushfd		
	}
	// 给NULL挂物理页
	__asm push fs
	DbgPrint("page PDE: %08X\n",*GetPDE((DWORD)page));
	DbgPrint("page PTE: %08X\n",*GetPTE((DWORD)page));
	DbgPrint("NULL PDE: %08X\n",*GetPDE(0));
	DbgPrint("NULL PTE: %08X\n",*GetPTE(0));
	DbgPrint("NULL挂物理页...\n");
	*GetPDE(NULL) = *GetPDE((DWORD)page);
	*GetPTE(NULL) = *GetPTE((DWORD)page);
	
	DbgPrint("page PDE: %08X\n",*GetPDE((DWORD)page));
	DbgPrint("page PTE: %08X\n",*GetPTE((DWORD)page));
	DbgPrint("NULL PDE: %08X\n",*GetPDE(0));
	DbgPrint("NULL PTE: %08X\n",*GetPTE(0));
	__asm pop fs
	__asm
	{
		popfd
		popad
		add esp,0x1000
		mov esp,ebp
		pop ebp
		iretd
	}
}

int _tmain(int argc, _TCHAR* argv[])
{	
	page = (DWORD *)VirtualAlloc(NULL,0x1000,MEM_COMMIT,PAGE_READWRITE);
	memset(page,0,0x1000); // 挂物理页
	DbgPrint = (DBGPRINT)GetProcAddress(LoadLibraryA("ntdll.dll"),"DbgPrint"); // 载入函数

	printf("在IDT表构建中断门，请在windbg中执行下面的指令：\n");
	printf("eq 8003f500 %04xee00`0008%04x\n",(DWORD)R0Function>>16,(DWORD)R0Function & 0x0000FFFF);
	getchar();

	// 用中断门提权，在R0读写PTE
	__asm int 0x20
	printf("NULL挂物理页成功.\n");
	*(int*)NULL = 0x12345678;
	printf("%x\n", page[0]);
	getchar();
	return 0;
}

